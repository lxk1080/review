三、 一 M 二 M
--
页面布局
CSS盒模型
DOM事件
HTTP协议
面向对象
原型链
通信、安全、算法

1、三栏布局 .............................................................................
--
float（兼容性好，要处理浮动问题）
absolute（脱离文档流，不建议采用）
flex（最完美，高度可以不固定）
table（兼容性好，高度可以不固定）
grid（网格布局）

2、CSS盒模型 ............................................................................
--
标准模型 + IE模型
content-box （标准模型）
border-box （IE模型）

--js设置获取盒模型对应的宽高
--
el.style.width/height （只能取到内联的样式）
el.currentStyle.width/height （只有IE支持）
window.getComputedStyle(el).width （兼容谷歌、火狐）
el.getBoundingClientRect().width（获取宽高 以及 元素的各个边到视窗左上的距离）

--边距重叠的情况
--
1、父子元素上下边距重叠
2、兄弟元素上下边距重叠
3、空元素上下边距重叠

BFC (块级格式化上下文)
--
BFC原理（渲染规则）
 1. BFC内的垂直方向会发生边距重叠
 2. BFC不会与浮动的元素重叠
 3. BFC是一个独立的容器，它外面的元素不会影响里面的，反之亦然
 4. BFC元素计算高度时，子元素即使是float也会参与计算
创建BFC
 1. float的值不为none
 2. position的值不为static或relative
 3. display属性为inline-block、table-cell、flex等等
 4. overflow不为visible
 
3、DOM事件  .........................................................................................
 	--DOM事件的级别
 		--DOM0
 			el.onclick = function(){}
 			// 友情提示：DOM1没有对事件方面的增加
 		--DOM2
 			el.addEventListener('click', function(){}, false) // 默认false代表冒泡
 		--DOM3
 			el.addEventListener('keyup', function(){}, false) // 相对于DOM2增加了许多事件
 			
 	--DOM事件模型（捕获、冒泡）
 	
 	--DOM事件流
 		1. 捕获
 		2. 目标阶段
 		3. 冒泡
 		-- 事件通过捕获到达目标元素，再从目标元素冒泡到window对象
 	
 	--DOM事件捕获的具体流程
 		-- window --> document --> html --> body --> ... --> 目标元素
 	
 	--Event对象的常见应用
 		event.preventDefault() // 阻止默认事件
 		event.stopPropagation() // 阻止冒泡
 		event.stopImmediatePropagation() // 事件响应优先级（例如为一个DOM元素绑定两个响应函数，那么在一个响应函数中使用该方法可以阻止其他的响应函数）
 		event.currentTarget // 通过事件代理（事件委托）方式绑定事件的情况， 可以得到用作事件代理的父级元素
 		event.target // 当前被点击的元素
 	
 	--自定义事件
		var event = new Event('custom')
		el.addEventListener('custom', function(){
			console.log('this is a custom event!')
		})
		el.dispatchEvent(event)
		
4、类型转换...................................................................................		
		--原始类型
			Number String Boolean null undefined Symbol
		--对象（复合类型）
			Object
		
		--显示类型转换
			--Number()
				--原始类型
					数值：还是数值
					字符串：如果可以被解析为数值，得到相应的数值，否则NaN，空字符串转为0
					布尔值：true --> 1, false --> 0
					undefined：NaN
					null：0
				--对象
					首先 obj.valueOf() 返回原始类型 --> Number()
									   返回复合类型 --> obj.toString() 返回原始类型 --> Number()
																	  返回复合类型 --> 报错
			--String()
				--原始类型
					将任何类型的值加上""即可
				--对象
					首先 obj.toString() 返回原始类型 --> String()
                                        返回复合类型 --> obj.valueOf() 返回原始类型 --> String()
                                                                      返回复合类型 --> 报错
			--Boolean()
					undefined 
					null
					NaN
					-0
					+0
					''
					-- 除了以上几个返回 false ，其他的全部是 true
		
		--隐式类型转换
			--四则运算
			--判断语句
			--Native调用，例如：console.log()、alert()
		
5、http协议 ..................................................................................
    --http协议的主要特点:
        简单快速（uri）
        灵活（不同数据类型的传输）
        无连接（连接一次就断掉）
        无状态（不会记住有谁连接过）

    --http报文
        --请求报文
            --请求行
                请求方式、页面地址、http协议、版本
            --请求头
                key-value值信息
            --空行
            --请求体
        --响应报文
            --状态行
            --响应头
            --空行
            --响应体

    --http方法
        --GET --获取资源
        --POST --传输资源
        --PUT --更新资源
        --DELETE --删除资源
        --HEAD --获得报文首部

    --GET和POST的区别
        4. GET请求在URL中传送的参数是有长度限制的，而POST没有。
        5. GET参数通过URL传递，POST放在Request body中。
        9. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

        1. GET在浏览器回退时是无害的，而POST会再次提交请求。
        2. GET产生的URL地址可以被收藏，而POST不可以。
        6. GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
        3. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

        7. GET请求只能进行url编码，而POST支持多种编码方式。
        8. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

    --长连接（持久连接 http/1.1版本）

    --管线化
        原本：请求1 -> 响应1 -> 请求2 -> 响应2
        管线化后：请求1 -> 请求2 -> 响应1 -> 响应2
        --将所有请求一次性发出，再接收响应
        1. 管线化机制通过持久化连接完成，仅 HTTP/1.1 支持
        2. 只有 GET 和 HEAD 请求可以进行管线化， POST 有所限制
        3. 初次创建连接时不应启动管线机制，因为服务器不一定支持 HTTP/1.1 的协议

6、原型链 .................................................................................
    --创建对象的几种方法
        --字面量
            var o1 = { name: 'lxk'}
            var o11 = new Object({name: 'lxk'})
        --构造函数
            var M = function(){this.name = 'lxk'}
            var o2 = new M()
        --Object.create()
            var p = {name: 'lxk'}
            var o3 = Object.create(p)

    --new运算符
        假设有构造函数foo
        var o = new foo()
        1. 一个新对象被创建（空对象），他继承自foo.prototype
        2. 构造函数被执行，可以传递参数，同时（this）上下文指向了新对象
        3. 如果构造函数执行后返回了一个对象，则最终返回这个对象，否则返回新建的这个对象

7、面向对象 ................................................................................
    -- 参考 js/面向对象与继承.html

8、通信 ....................................................................................
    --同源策略：源：协议+域名+端口号
        -- 一个域里的脚本不能获得另一个域内的资源（cookie、dom、ajax）

    --前后端通信方式
        --ajax（同源）
        --WebSocket（不受同源策略限制）
        --CORS（支持跨域，也支持同源，全称：跨域资源共享--Cross-origin resource sharing）

    --原生 ajax 创建
        -- 参考 js/ajax.js

    --跨域通信的几种方式
        -- JSONP（利用script标签可以跨域请求资源的特性）
        -- Hash（Hash改变，页面不刷新，页面间跨域）
        -- postMessage（H5增加，页面间跨域）
        -- WebSocket（服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息）
        -- CORS（ajax的变种--fetch，请求如果是跨域的，就会自动添加一些附加的头信息--Origin字段）

9、安全 .....................................................................................
    --CSRF
        CSRF: 跨站请求伪造，Cross-site request forgery
        攻击原理：
            1. 用户在此网站登录认证过
            2. 网站某个接口存在漏洞
        防御措施：
            1. Token认证
            2. referer认证
            3. 隐藏令牌
    --XSS
        XSS: 跨域脚本攻击，Cross-site scripting，向页面注入脚本，例如在评论框注入script标签等
        攻击类型：
            1. 反射型：xss存储在url中，localhost:3000?xss=<img src='null' onerror='alert(1)'>
            2. 存储型：xss存储在数据库、内存、文本中
        防御措施：
            1. 编码（前端或后端编码转义）
            2. 过滤（前端反转义 --> domparser(过滤script、style、link、iframe、frame、onclick、onerror等标签或属性)）
            3. 校正（使用domParse，校正不配对的DOM标签）





