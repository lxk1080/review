## Project Design

### 已有的项目设计

### 可能的项目设计

1. 设计一个前端统计 SDK
   - [参考演示链接](https://coding.imooc.com/lesson/562.html#mid=51083)
   - 基本要素：pv、自定义事件、性能统计、错误监控、发送数据
   - 涉及到的技术点：
     - 性能监控使用浏览器 `performance.timing` API
     - 错误监控使用 `onerror` 事件，Promise 的 catch 未捕获错误，使用 `unhandledrejection` 事件
       - 如果是 Vue 或 React，还需要配合各自的错误监控 API
         - Vue 的 `errorCaptured` 生命周期和 `errorHandler` 全局配置
         - React 的 `ErrorBoundary` 组件
     - 发送数据使用 `<img/>` 标签发送，可跨域
     - 关于错误监控，这里补充一下，一般需要用到 source-map 文件，这个一般在 webpack 或其它工程工具配置就可以
       - 但是有个问题就是，如果不是开源项目，一般来讲，source-map 文件是不应该被请求到的（浏览器上没有），那这时如果线上报错，我们就无法获得报错源代码的位置
       - 我们只能得到报错的信息，这个时候就需要把 source-map 文件放在服务器，然后把报错信息传给服务器，让服务器配合 source-map 找到报错具体位置


2. SPA 和 MPA 该如何选择？
   - SPA 页面
     - 特点
       - 功能较多，一个页面展示不完（需要共享数据）
       - 以操作为主，非展示为主
       - 适合一个综合 Web 应用
     - 场景
       - 大型后台管理系统
       - 比较复杂的 WebApp，如外卖 H5
   - MPA 页面
     - 特点
       - 功能较少，一个页面展示的完（各页面不需要共享数据）
       - 以展示为主，操作较少
       - 适合孤立页面
     - 场景
       - 分享页，如腾讯文档分享出去
       - 新闻详情页，微信公众号发布的页面
   - 虽然说 MPA 页面能做的，SPA 也可以，但是处于对性能的考虑，还是有些区别的
     - 就例如 MPA 的分享页面，html 里面只需要引入对应的 js 文件即可，功能非常单一纯粹
     - 但如果是 SPA 页面，这个 html 是需要兼容所有页面功能的（当然这里面也可以拆分为很多其它的小 js 文件，但是效果肯定没 MPA 好，没有 MPA 纯粹）


3. 设计一个 H5 编辑器的数据模型和核心功能
   - [参考演示链接](https://coding.imooc.com/lesson/562.html#mid=51088)
   - 几个核心要点：
     - 页面中的组件用数组存储（有序），样式属性或事件可以汇集到一个 style、events 里面
     - 给页面数据添加一个核心字段：当前激活的组件 ID，用于共享数据
     - 图层不要单独搞数据，而是从页面数据 computed 而来，图层只是个缩影，一切数据的改变都应该在页面数据中进行
   - 系统的 **数据结构设计** 至关重要，比优化算法更重要
   - **要看整体设计，抓核心问题，而非纠细节**
     - 如果你纠结这个代码每一步怎么写出来，那恐怕是想不太明白
     - 不要纠细节，重要的是，搞清楚问题的核心点


4. 设计一个 “用户-角色-权限” 的模型和功能
   - [参考链接演示](https://coding.imooc.com/lesson/562.html#mid=51089)
   - 就是 RBAC 模型 - Role-Based access control，基于角色的访问控制
     - 总共五张表
       - 用户表
       - 角色表
       - 权限表
       - 用户-角色关联表
       - 角色-权限关联表
     - 用户管理：增删改查（用户表），绑定角色（用户-角色关联表）
     - 角色管理：增删改查（角色表），绑定权限（角色-权限关联表）
     - 权限管理：增删改查（权限表）
     - 对于前端而言，可以用数组或 Set、Map 来管理这些数据


5. 开发一个 H5 抽奖页，可能需要后端提供哪些接口？
   - 这个题咋说呢，可能主要是想说，拿到一个需求后，我们心里需要演示一下它的业务流程（但一般情况下，这些过程都应该被写在产品原型里）
     - 之前在平安工作时，这种抽奖、领红包、薅羊毛活动多的很
   - 接下来说说看：
     - 登录接口（抽奖，总要有个人来抽吧，得先弄清楚是谁，进入页面检查登录状态）
     - 是否抽过奖接口（抽过了按钮变灰，没抽过才去抽，具体看业务，有可能支持抽多次）
     - 抽奖接口（抽奖的操作肯定不能放在前端，需要后端执行，并返回结果）
     - 主要就是以上三个，但实际业务可能有所扩展，根据经验来看，可能还有：
       - 引导去分享（可能需要好友接口）
       - 页面埋点（发送页面统计数据的接口）
         - PV 多少，有几个人点了抽奖按钮，又有几个人点了分享
   - 最后，人生建议：**技术一定要去熟悉业务，因为技术永远是为业务服务的**
     - 牢记这句话，可以保你永远不会出现在公司的裁员名单里（除非你的技术能力过差。。）
     - 不要觉得自己可以专攻技术，业务无所谓，当然，如果你的技术过硬的话另说


6. 阶段总结
   - 关于项目设计这块，首先你应该明确有一个认知：技术永远是为业务服务的（业务等于产品）
   - 而项目设计这件事，正是把技术和业务连接在一起的这么个过程
     - 题外话，业务是为销售和运营服务的，销售运营为公司服务，公司为客户服务，客户等于 money 。。扯远了。。
   - 那什么是为技术服务的？或者说技术的核心是什么？
   - 答案是：数据结构和算法，其中数据结构在前，算法在后
   - 所以，当你遇到：设计一个 “xxx” 的模型和功能，这样的问题时，首先需要搞清楚业务流程，然后对于技术：
   - 第一步想的，应该永远是：数据结构如何设计，数据怎么存储
   - 后续的处理计算过程（算法），这一块对于前端来说就是业务执行流程
   - 如果你的数据结构设计的好，那么写业务流程代码时，对于数据的处理就会很轻松，业务逻辑也会更清晰


7. 你作为项目负责人，是如何做技术选型的？
   - 这个问题其实每个人都有一些答案，但是可能并不全面，这里给个选型思路
   - 首先，不关选型什么技术，都需要有一个底层认知：要站在团队的角度，而非个人的角度
   - 然后还有个重要的点，不要人云亦云，不要相信网上说的，要有独立思考的能力
     - 例如：React 比 Vue 好、Svelte 无需虚拟 DOM 是未来、TS 比 JS 要高级、等等类似的言论都不可信
     - 记住，技术是为业务服务的，没有最好的技术，只有最适合的技术
     - 就例如国外很多网站还是基于 WordPress 搭建的（还是得用 PHP，虽然它是上个世纪的技术，但是它解决了网站搭建问题）
   - 下面来说说：
     - 公司是否已有经验积累（如果公司其它团队也在做类似的项目或使用相同的框架，那其实已经有了很多成熟的组件，那你得考虑是否可以用现成的？）
     - 社区是否足够成熟（假如你用最新的前端框架去做项目，做到一半发现社区没有滚屏开源库，那你还得自己造轮子？）
     - 团队成员的学习成本（如果一个项目团队有 5 个人，4 个人会 Vue，一个人会 React，那你会选择啥？）
     - 管理成本（假如你需要快速写一个脚本功能插件，快速上线，结果你用 TS 调类型就花了大量时间，那你还有必要使用 TS 吗？）
       - 除非 TS 全写 any，那这时 TS 就形同虚设了，更是无用功，后期又要付出对 TS 类型的维护成本
     - 运维成本（首屏优化上来就用 SSR，结果部署的时候出现问题，需要其他部门同事配合去解决问题）


8. 设计一个 H5 图片懒加载 SDK
   - 主要有两种方式：
     - 监听 scroll 事件，计算图片元素距离视窗的距离
       - 参考代码：[图片懒加载-scroll](../writeCode2/图片懒加载-scroll.html)
       - 主要是利用 getBoundingClientRect 这个 DOM-API 计算元素顶部距离视口顶部的距离
       - 注意一开始首屏页面的时候，需要初始化一下（这时还没有滚动操作）
     - 使用 IntersectionObserver API 监听图片是否出现在视窗内
       - 参考代码：[图片懒加载-iso](../writeCode2/图片懒加载-iso.html)
       - 没啥好说的，只是要注意下，图片加载完成后，把监听解绑掉即可
   - 这两种方式对比：
     - 代码复杂度上：
       - IntersectionObserver：写起来更简单，响应事件就好
       - scroll：需要自行判断何时加载，还需要做初始化，但在控制上可以更细粒度
     - 加载速度：
       - IntersectionObserver：理论上加载更快，只要事件响应便立刻加载
       - scroll：由于使用节流函数，可能会延迟一点时间加载，但是差距不大
     - 扩展性上：
       - IntersectionObserver：可以做虚拟列表，但是无法优化体验
       - scroll：可以做虚拟列表，并且可以通过监听图片位置做预加载


9. 扩展：关于 B 端、C 端和 SaaS 的区别
   - 可以参考文章：[转至文章链接](https://coding.imooc.com/lesson/562.html#mid=50858)
