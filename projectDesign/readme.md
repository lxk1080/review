## Project Design

### 已有的项目设计

1. 连横智能埋点系统
   - 职责：前端技术负责人
   - 整体介绍以及运行流程？
     - 包含三个部分，易点通平台（配置）、JSSDK（连接）、CssSelector（工具），我主要做 JSSDK，易点通平台和 CssSelector 做了环境搭建，写了部分代码
     - 根据配置，埋点类型包括：页面的进入和退出、元素的点击（区域点击）和曝光（区域曝光）
     - 如果没有配置，则使用自动埋点，所有可被点击的元素自动上报埋点
     - 参数解析，可以输入一些表达式获取元素对应组件类的状态值或属性值
     - 区域的延迟上报功能，快速滚动，短时间内多元素曝光，此时不急着上报，等滚动结束，批量上报
   - 具体的功能点有哪些（React + React-Native）？
     - 配置的加载：优先加载远程配置，200ms 的缓冲时间，如果请求未返回，则开始请求 DB，还没有的话，最后加载本地配置
     - React 中如何判断一个 dom 元素上是否绑有 click 事件？
       - 要知道，react 里面的事件机制是合成事件，所以并不会有真的 click 事件绑定在元素上，那该怎么判断？
       - 合成事件依赖于冒泡机制，在 safari 浏览器中，那些非交互式的元素不能够正确的触发冒泡，为了让冒泡生效，只要在 dom 元素上加一个空函数即可
       - 所以 React 加了个空函数，`noop = () => {}; onclick = noop;` 在 React 18.x 中依然保留这一做法，可以通过元素的事件监听器找到这一函数
     - 使用 IntersectionObserver API 监听元素的曝光
     - 使用 MutationObserver API 监听 Dom 元素的增加和删除，检测其上是否有事件元素
       - 每当有元素显示或隐藏时，都需要去更新元素上的事件绑定和解绑，包括点击事件和曝光事件
     - 区域延迟上报功能（根据配置，是否需要延迟上报，判断哪些事件需要延迟，每个事件都有个类型，同类型的作为一批上报）
       - 实现了一个监听 scroll 开始和结束事件的类，滚动结束后，批量上报
     - 参数解析是如何实现的？
       - 主要是通过 `new Function()` 函数解析 JS 字符串式的代码
       - 然后通过预设的一些对象获取对应的值（预设的对象：组件实例、组件 state 对象、组件 props 对象）
       - 还可以通过 fiberNode 的信息找到父子或兄弟节点，并拿到对应组件的状态信息
         - 每一个 fiberNode 都有一个 tag 类型，我们可以根据此类型，加上我们提前设置好的静态属性（`static isWithCompHoc = 'Y'`）找到组件
     - 其它的一些细节：
       - 配置禁止自动上报埋点的区域（例如密码输入区）
       - 如果点击的是 img 元素，还会上报这张图片的 url 链接（可能是 base64 格式的）
       - 诸如此类的细节因素还有很多。。
   - 如何实现 Vue 版本？
     - Vue 中如何判断一个 dom 元素上是否绑有 click 事件？
       - 通过重写 addEventListener 方法的方式，使每个元素在绑定事件时可以被 JSSDK 感知到
     - 通过创建一个全局组件 Page 来获取页面 pageId，通过 render 函数直接创建，让其在项目使用时编译，以保证 Page 组件的对应的 Vue 版本与使用的项目一致
       - 不使用 .vue 模板创建 Page 组件，是因为 Page 组件可能在 Vue2 或 Vue3 使用，不同版本的 Vue 打包出来的文件是不一样的
     - 重写 v-for 的编译方法 renderList，自动在子元素上添加 data-index 属性
       - 在 vue2 中，此方法直接挂载在 Vue 类中，可以重写，在 vue3 中，vue 无默认导出，无法实现
     - 注意 keep-alive 的问题，切换路由，不会重新走 Vue 生命周期
       - 需要使用 activated / deactivated 去手动的激活或卸载 JSSDK 的功能
       - 如果不手动卸载，进入页面和退出页面埋点无法触发、增删监听函数不会卸载
   - 实现 Taro 版本需要注意什么（React + Vue）？
     - 需要更改 API 的使用，包括：localStorage、request、自定义事件等等
     - 小程序内需要在编译中配置：mini.runtime.enableMutationObserver 为 true，启用 mutationObserver API，默认不开启
     - 小程序的 IntersectionObserver 有点残缺，一个 IntersectionObserver 实例只能监听一个元素
     - 小程序不支持 Function 函数（被微信重写），需要自己实现 JS 解析器（简易的）
     - H5、微信小程序、支付宝小程序使用自动埋点时，自动生成的 eid 不一致（在区域点击和自动埋点的时候，eid 会根据 Dom 结构自动生成，通过加密的方式获取 hash 值）
       - 原因：eid 是根据 Dom 树结构加密生成的，在微信和支付宝中，页面的渲染可能会自动加上一些外层元素，从而导致 eid 生成不一致
       - 解决：需要在您的渲染页面的根元素上加上 id 属性即可
         - 因为 jssdk 在生成某一个元素的 xpath 路径时，遇到 id 属性会直接取该 id 为 xpath 路径的开始
         - 当然，这个 id 不会取 Taro 自动生成的 id，需要开发者自行定义
   - 工具 CssSelector 的主要 API 是什么？
     - `document.elementsFromPoint(x, y)` 可以获取从内层到外层所有的元素
   - 项目的不足有哪些？
     - IntersectionObserver 无法监听到通过 tramsform 来改变位置的元素，无法采集曝光
     - 一开始接入的时候，成本会比较大
     - 最好使用 id 作为选择器，否则元素的位置会变，生成的 eid 不一致
   - 其它的细节部分可以参考以下文章和库
     - [uba-使用说明](https://juejin.cn/editor/drafts/7301910992312188928)
     - [uba-设计方案](https://juejin.cn/editor/drafts/7277495277631143995)
     - [uba-代码库](https://github.com/lxk1080/pia)

### 可能的项目设计

1. 设计一个前端统计 SDK
   - [参考演示链接](https://coding.imooc.com/lesson/562.html#mid=51083)
   - 基本要素：pv、自定义事件、性能统计、错误监控、发送数据
   - 涉及到的技术点：
     - 性能监控使用浏览器 `performance.timing` API
     - 错误监控使用 `onerror` 事件，Promise 的 catch 未捕获错误，使用 `unhandledrejection` 事件
       - 如果是 Vue 或 React，还需要配合各自的错误监控 API
         - Vue 的 `errorCaptured` 生命周期和 `errorHandler` 全局配置
         - React 的 `ErrorBoundary` 组件
     - 发送数据使用 `<img/>` 标签发送，可跨域
     - 关于错误监控，这里补充一下，一般需要用到 source-map 文件，这个一般在 webpack 或其它工程工具配置就可以
       - 但是有个问题就是，如果不是开源项目，一般来讲，source-map 文件是不应该被请求到的（浏览器上没有），那这时如果线上报错，我们就无法获得报错源代码的位置
       - 我们只能得到报错的信息，这个时候就需要把 source-map 文件放在服务器，然后把报错信息传给服务器，让服务器配合 source-map 找到报错具体位置


2. SPA 和 MPA 该如何选择？
   - SPA 页面
     - 特点
       - 功能较多，一个页面展示不完（需要共享数据）
       - 以操作为主，非展示为主
       - 适合一个综合 Web 应用
     - 场景
       - 大型后台管理系统
       - 比较复杂的 WebApp，如外卖 H5
   - MPA 页面
     - 特点
       - 功能较少，一个页面展示的完（各页面不需要共享数据）
       - 以展示为主，操作较少
       - 适合孤立页面
     - 场景
       - 分享页，如腾讯文档分享出去
       - 新闻详情页，微信公众号发布的页面
   - 虽然说 MPA 页面能做的，SPA 也可以，但是处于对性能的考虑，还是有些区别的
     - 就例如 MPA 的分享页面，html 里面只需要引入对应的 js 文件即可，功能非常单一纯粹
     - 但如果是 SPA 页面，这个 html 是需要兼容所有页面功能的（当然这里面也可以拆分为很多其它的小 js 文件，但是效果肯定没 MPA 好，没有 MPA 纯粹）


3. 设计一个 H5 编辑器的数据模型和核心功能
   - [参考演示链接](https://coding.imooc.com/lesson/562.html#mid=51088)
   - 几个核心要点：
     - 页面中的组件用数组存储（有序），样式属性或事件可以汇集到一个 style、events 里面
     - 给页面数据添加一个核心字段：当前激活的组件 ID，用于共享数据
     - 图层不要单独搞数据，而是从页面数据 computed 而来，图层只是个缩影，一切数据的改变都应该在页面数据中进行
   - 系统的 **数据结构设计** 至关重要，比优化算法更重要
   - **要看整体设计，抓核心问题，而非纠细节**
     - 如果你纠结这个代码每一步怎么写出来，那恐怕是想不太明白
     - 不要纠细节，重要的是，搞清楚问题的核心点


4. 设计一个 “用户-角色-权限” 的模型和功能
   - [参考链接演示](https://coding.imooc.com/lesson/562.html#mid=51089)
   - 就是 RBAC 模型 - Role-Based access control，基于角色的访问控制
     - 总共五张表
       - 用户表
       - 角色表
       - 权限表
       - 用户-角色关联表
       - 角色-权限关联表
     - 用户管理：增删改查（用户表），绑定角色（用户-角色关联表）
     - 角色管理：增删改查（角色表），绑定权限（角色-权限关联表）
     - 权限管理：增删改查（权限表）
     - 对于前端而言，可以用数组或 Set、Map 来管理这些数据


5. 开发一个 H5 抽奖页，可能需要后端提供哪些接口？
   - 这个题咋说呢，可能主要是想说，拿到一个需求后，我们心里需要演示一下它的业务流程（但一般情况下，这些过程都应该被写在产品原型里）
     - 之前在平安工作时，这种抽奖、领红包、薅羊毛活动多的很
   - 接下来说说看：
     - 登录接口（抽奖，总要有个人来抽吧，得先弄清楚是谁，进入页面检查登录状态）
     - 是否抽过奖接口（抽过了按钮变灰，没抽过才去抽，具体看业务，有可能支持抽多次）
     - 抽奖接口（抽奖的操作肯定不能放在前端，需要后端执行，并返回结果）
     - 主要就是以上三个，但实际业务可能有所扩展，根据经验来看，可能还有：
       - 引导去分享（可能需要好友接口）
       - 页面埋点（发送页面统计数据的接口）
         - PV 多少，有几个人点了抽奖按钮，又有几个人点了分享
   - 最后，人生建议：**技术一定要去熟悉业务，因为技术永远是为业务服务的**
     - 牢记这句话，可以保你永远不会出现在公司的裁员名单里（除非你的技术能力过差。。）
     - 不要觉得自己可以专攻技术，业务无所谓，当然，如果你的技术过硬的话另说


6. 阶段总结
   - 关于项目设计这块，首先你应该明确有一个认知：技术永远是为业务服务的（业务等于产品）
   - 而项目设计这件事，正是把技术和业务连接在一起的这么个过程
     - 题外话，业务是为销售和运营服务的，销售运营为公司服务，公司为客户服务，客户等于 money 。。扯远了。。
   - 那什么是为技术服务的？或者说技术的核心是什么？
   - 答案是：数据结构和算法，其中数据结构在前，算法在后
   - 所以，当你遇到：设计一个 “xxx” 的模型和功能，这样的问题时，首先需要搞清楚业务流程，然后对于技术：
   - 第一步想的，应该永远是：数据结构如何设计，数据怎么存储
   - 后续的处理计算过程（算法），这一块对于前端来说就是业务执行流程
   - 如果你的数据结构设计的好，那么写业务流程代码时，对于数据的处理就会很轻松，业务逻辑也会更清晰


7. 你作为项目负责人，是如何做技术选型的？
   - 这个问题其实每个人都有一些答案，但是可能并不全面，这里给个选型思路
   - 首先，不关选型什么技术，都需要有一个底层认知：要站在团队的角度，而非个人的角度
   - 然后还有个重要的点，不要人云亦云，不要相信网上说的，要有独立思考的能力
     - 例如：React 比 Vue 好、Svelte 无需虚拟 DOM 是未来、TS 比 JS 要高级、等等类似的言论都不可信
     - 记住，技术是为业务服务的，没有最好的技术，只有最适合的技术
     - 就例如国外很多网站还是基于 WordPress 搭建的（还是得用 PHP，虽然它是上个世纪的技术，但是它解决了网站搭建问题）
   - 下面来说说：
     - 公司是否已有经验积累（如果公司其它团队也在做类似的项目或使用相同的框架，那其实已经有了很多成熟的组件，那你得考虑是否可以用现成的？）
     - 社区是否足够成熟（假如你用最新的前端框架去做项目，做到一半发现社区没有滚屏开源库，那你还得自己造轮子？）
     - 团队成员的学习成本（如果一个项目团队有 5 个人，4 个人会 Vue，一个人会 React，那你会选择啥？）
     - 管理成本（假如你需要快速写一个脚本功能插件，快速上线，结果你用 TS 调类型就花了大量时间，那你还有必要使用 TS 吗？）
       - 除非 TS 全写 any，那这时 TS 就形同虚设了，更是无用功，后期又要付出对 TS 类型的维护成本
     - 运维成本（首屏优化上来就用 SSR，结果部署的时候出现问题，需要其他部门同事配合去解决问题）


8. 设计一个 H5 图片懒加载 SDK
   - 主要有两种方式：
     - 监听 scroll 事件，计算图片元素距离视窗的距离
       - 参考代码：[图片懒加载-scroll](../writeCode2/图片懒加载-scroll.html)
       - 主要是利用 getBoundingClientRect 这个 DOM-API 计算元素顶部距离视口顶部的距离
       - 注意一开始首屏页面的时候，需要初始化一下（这时还没有滚动操作）
     - 使用 IntersectionObserver API 监听图片是否出现在视窗内
       - 参考代码：[图片懒加载-iso](../writeCode2/图片懒加载-iso.html)
       - 没啥好说的，只是要注意下，图片加载完成后，把监听解绑掉即可
   - 这两种方式对比：
     - 代码复杂度上：
       - IntersectionObserver：写起来更简单，响应事件就好
       - scroll：需要自行判断何时加载，还需要做初始化，但在控制上可以更细粒度
     - 加载速度：
       - IntersectionObserver：理论上加载更快，只要事件响应便立刻加载
       - scroll：由于使用节流函数，可能会延迟一点时间加载，但是差距不大
     - 扩展性上：
       - IntersectionObserver：可以做虚拟列表，但是无法优化体验
       - scroll：可以做虚拟列表，并且可以通过监听图片位置做预加载


9. 扩展：关于 B 端、C 端和 SaaS 的区别
   - 可以参考文章：[转至文章链接](https://coding.imooc.com/lesson/562.html#mid=50858)
